---
title: Distributed Builds
layout: section
---
ifdef::backend-html5[]
:toc:
ifdef::env-github[:imagesdir: ../resources]
ifndef::env-github[:imagesdir: ../../resources]
:hide-uri-scheme:
endif::[]

Never run builds on the Jenkins controller in production environments.
Out of the box, Jenkins is set up to run builds on the built-in controller node.
This makes it easier to get started with Jenkins,
but, on  production instances,
builds should only be executed on nodes that are external to the controller.

A build job that uses an agent running on the built-in controller node
may be able to access Jenkins configuration files and the workspaces of other builds.
An agent could also request information
that belongs to other teams or organizations that share the controller.
Configuring Jenkins as a
link:/doc/book/scaling/architecting-for-scale/#distributed-builds-architecture[distributed build system]
enhances the security of your Jenkins instance
as well as improving its performance and making it more stable.
This is because builds that run on the built-in node
have the same level of access to the controller file system as the Jenkins process itself.
Configuring your Jenkins instance so that builds
execute on agents running on separate nodes
protects the Jenkins controller from malicious (or just broken) build scripts.

When distributed builds are implemented,
the Jenkins controller serves HTTP requests
and stores all important information related to the builds.
Nodes are separate physical or virtual machines that are configured.
The Jenkins controller manages these nodes,
but the agents manage the task execution on behalf of the Jenkins controller
and supply most of the computing power required to build and test the software.
Different nodes can run different operating systems and different tools,
enabling one Pipeline to build and test the same software
for a variety of platforms.

[NOTE]
====
A job that performs administrative tasks such as backups may run on the controller,
but be sure to label the executor with a hard-to-guess label
and only allow it to be used by jobs that specify that label.
An executor can be temporarily configured on the controller
long enough to run the administrative task
but no executors should be configured on the controller at other times
to ensure that no builds execute on the controller
since a clever Pipeline author may be able to work around the label restriction.

You can install the plugin:job-restrictions[Job Restrictions Plugin]
to ensure that builds do not run on the controller
even if executors are configured.
====

An agent can also write malicious code to its local disk so that the node is tainted
and can infect a later build.
For maximum security, run all builds on ephemeral agents in the cloud
so that they are destroyed at the end of each build job.

By extension, you also should not run agents on the same Docker host as the controller.

== Distributed Components

A Jenkins distributed builds instance includes the following components:

Jenkins controller::

The Jenkins controller is the Jenkins service itself
and is where Jenkins is installed.
It is a webserver that also acts as a "brain"
for deciding how, when and where to run tasks.
Management tasks (configuration, authorization, and authentication)
are executed on the controller, which serves HTTP requests.
Files written when a Pipeline executes are written to the filesystem on the controller
unless they are off-loaded to an artifact repository such as Nexus or Artifactory.

Nodes::

Nodes are the "machines" on which build agents run.

The Jenkins controller itself runs on a special _built-in node_.

Agents::

Agents manage the task execution on behalf of the Jenkins controller
by using executors.
An agent is actually a small (170KB single jar) Java client process
that connects to a Jenkins controller and is assumed to be unreliable.
An agent can use any operating system that supports Java.
Tools required for builds and tests are installed on the node where the agent runs;
they can be installed directly or in a container (Docker or Kubernetes).
Each agent is effectively a process with its own PID (Process Identifier) on the host machine.

In practice, nodes and agents are essentially the same but it is good to remember that they are conceptually distinct.

Executors::

An executor is a slot for execution of tasks;
effectively, it is a thread in the agent.
The number of executors on a node defines the number of concurrent tasks
that can be executed on that node at one time.
In other words, this determines the number of concurrent Pipeline `stages`
that can execute on that node at one time.

The proper number of executors per build node must be determined
based on the resources available on the node
and the resources required for the workload.
When determining how many executors to run on a node,
consider CPU and memory requirements
as well as the amount of I/O and network activity:

* One executor per node is the safest configuration.
* One executor per CPU core may work well
if the tasks being run are small.
* Monitor I/O performance, CPU load, memory usage, and I/O throughput carefully
when running multiple executors on a node.

== Implementing Distributed Builds

To implement distributed builds on your Jenkins instance,
you must do the following:

* Create nodes and agents where the builds can run.
* Prevent builds from running on the controller.

This section also includes other tips and tricks you can use.

=== Create Nodes and Agents for Builds

To implement a distributed builds architecture for your Jenkins instance,
you must configure nodes and agents to use for your builds.
See
link:https:/doc/book/managing/nodes/[Managing Nodes]
for instructions.

=== Prevent Builds from Running on the Controller

You must also prevent builds from running on the built-in controller node.
To do this:

. Navigate to _Manage Jenkins Â» Manage Nodes and Clouds_.
. Select _master_ in the list, then select _Configure_ in the menu.
. Set the number of executors to 0.
. Save the configuration.

NOTE: A job that performs administrative tasks such as backup may run on the controller,
but be sure to label the executor with a hard-to-guess label
and only allow it to be used by jobs that use that label.
Jenkins should normally be configured to have 0 executors on the controller,
and then be temporarily reconfigured to have 1 executor
long enough to run the backup or other administrative task.
Unless the number of executors is 0,
it is possible for a build to run on the controller.

=== Other Tips and Tricks

Another way to prevent builds from running on the controller
is to use a plugin such as the plugin:job-restrictions[Job Restrictions Plugin]
to limit which jobs can be run on certain nodes (like the built-in controller node),
independent of what your less trusted users may use as label expression in their job configurations.

If you do not have any other computers on which to run agents,
you can run an agent process as a different operating system user on the same system
to achieve a similar isolation effect.
In this case,
be sure that the agent process has neither read nor write file system access
to the Jenkins home directory,
and that the agent process cannot use `sudo` or other practices to elevate its own permissions.

